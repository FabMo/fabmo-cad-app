<!DOCTYPE html>

<! jward 2016 >

<html lang="en">
<head>
	<title>CAD</title>
	<meta name="viewport" content="user-scalable=no" charset="utf-8"/>
	<link href="css/style.css" rel="stylesheet">
	<script src="js/libs/jquery-3.1.1.min.js"></script>
	<script src="js/libs/jquery.mousewheel.min.js"></script>
	<script src="js/libs/fabmo.min.js"></script>
	<script src="js/libs/clipper.js"></script>
	<script src="js/draw.js"></script>
	<script src="js/make.js"></script>
</head>

<body onload=" draw(); defineStock([3,3]);">

<canvas id="cad-canvas"></canvas>

<textarea id="text-area" spellcheck="false" cols="40" rows="2" autocomplete="off">FabMo CAD ('?' for help)&#13;>></textarea>
<input type="submit" id="line" value="line"/>
<input type="submit" id="rectangle" value="rectangle"/>
<input type="submit" id="circle" value="circle"/>

<div id="grid">grid = 0.25"</div>
<input type="submit" id="make" value="make" onclick="make()"/>
<input type="submit" id="clear" value="clear" onclick="clearAll()"/>
<input type="submit" id="undo" value="undo" onclick="undo()"/>
<a href="#" id="download">download</a>
</body>

<script>


//TODO
//
//rectangle and polygon commands
//
//

$(window).resize(function(){
	draw()
})

var fabmo = new FabMoDashboard()

var gridSpace = 20
var gridIncrement = 10
var grid = 4 //1/4"
var stock = []
var tool = 0.125
var units = 'inch' //inch or mm
var scale = 1000   //
var layer = 0
var output = 'gcode'  //sbp gcode dxf
var cutDepth = 0.05

var dogbone = false
var dogbones = []
var bones =[]
var dbo
var inside = true

var sf = 1

var zoom = 2
var panX = 0
var panY = 0

var mouseX
var mouseY
var ts
var pan = false
var panStart = new Object()
var panEnd = new Object()
var mousePanX = 0 
var mousePanY = 0

var point = [0,0]

var lines = []

var polygons = []
var pockets = []
var cutout = []


var help="\
circle \'x1\',\'y1\',\'r\'<br>\n\
clear \'new drawing\'<br>\n\
cutdepth=\'z\'<br>\n\
cutin (offset toolpath in)<br>\n\
cutout (offset toolpath out)<br>\n\
dogbone (make dogbone fillets)<br>\n\
dogbone= \'1\' \'-1\'<br>\n\
g,\'gcode\'<br>\n\
grid=\'space\'<br>\n\
line \'x1\',\'y1',\'x2\',\'y2\' <br>\n\
line \'x2\',\'y2\'<br>\n\
makedxf (download dxf)<br>\n\
makeg (download gcode)<br>\n\
makesbp (download sbp)<br>\n\
mousewheel/pinch \'zoom\'<br>\n\
output=\'dxf\' \'gcode\' \'sbp\'<br>\n\
pocket (pocket toolpath)<br>\n\
rect\'x\',\'y\',\'lx\',\'ly\'<br>\n\
sbp,\'sbp command\'<br>\n\
settings<br>\n\
star\'x\',\'y\',\'r\'<br>\n\
stock=\'x\',\'y\'<br>\n\
tool=\'d\'<br>\n\
touch hold (pan)<br>\n\
units=inch<br>\n\
"

function rmComma(s,v){

	if(s.charAt(v)==','){
		s = s.replace(/\,/,"")
	}
	return s

}

//cmd
$("#text-area").keyup(function(e){

	var cmd = document.getElementById('text-area').value
	this.selectionStart = this.selectionEnd = this.value.length
	
	if(e.keyCode == 13){

		cmd = cmd.replace(/.*?\n\>\>/,'')
		cmd = cmd.replace(/\n/g,'')
		cmd = cmd.toLowerCase()

		//geometry
		if(cmd.substring(0,6)=="circle"){
			cmd = rmComma(cmd,6)
			pts = cmd.substring(6).split(',')
			scalePts(pts)
			circle(pts)	
		}
		else if(cmd.substring(0,4)=="line"){
			cmd = rmComma(cmd,4)
			pts = cmd.substring(4).split(',')
			scalePts(pts)
			line(pts)
		}
		else if((cmd.substring(0,4)=="rect") && (cmd.substring(0,9)!="rectangle")){
			cmd = rmComma(cmd,4)
			pts = cmd.substring(4).split(',')
			scalePts(pts)
			rect(pts)
		}
		else if(cmd.substring(0,4)=="star"){
			console.log('star')
			cmd = rmComma(cmd,4)
			pts = cmd.substring(4).split(',')
			scalePts(pts)
			star(pts)	
		}
		//cuts
		else if(cmd=="cutin"){
			console.log('cutin')
			cutOut(false)
		}
		else if(cmd=="cutout"){
			console.log('cutout')
			cutOut(true)
		}
		else if(cmd.substring(0,2)=="g,"){
			cmd=cmd.substring(2,cmd.length)
			fabmo.runGCode(cmd)
		}
		else if(cmd=="dogbone"){
			dogbones=[]
			makePath()
			pockets=[]
			cutout=[]
			find90()
		}
		else if(cmd.substring(0,8)=="dogbone="){
			console.log('dogbone')
			cmd = rmComma(cmd,8)
			if(cmd.substring(8)=='-1'){
				inside=true
			}
			else if(cmd.substring(8)=='1'){
				inside=false
			}
			dogbones=[]
			makePath()
			pockets=[]
			cutout=[]
			find90()
		}
		else if(cmd=="pocket"){
			console.log('pocket')
			pocket()
		}
		else if(cmd.substring(0,4)=="sbp,"){
			cmd=cmd.substring(4,cmd.length)
			fabmo.runSBP(cmd)
		}
		//settings
		else if(cmd.substring(0,9)=="cutdepth="){
			cutDepth=parseFloat(cmd.substring(9))
			cmd = 'cutDepth = -' + cutDepth +"\""
		}
		else if(cmd.substring(0,5)=="grid="){
			stock[0]=stock[0]/grid
			stock[1]=stock[1]/grid
			grid=1/(parseFloat(cmd.substring(5)))
			//todo set zoom
			document.getElementById('grid').innerHTML = 'grid = ' + (parseFloat(cmd.substring(5))) + "\""
			cmd = 'grid = ' + (parseFloat(cmd.substring(5))) +"\""			
			defineStock(stock)
		}
		else if(cmd.substring(0,7)=="output="){
			output=(cmd.substring(7))
			if(output=='sbp'){
				cmd = 'output=sbp (shopbot program)'
			}
			else if(output=='gcode'){
				cmd = 'output=gcode'
			}
			else if(output=='dxf'){
				cmd = 'output=dxf'
			}
			else{
				output = 'sbp'
				cmd = output
			}
		}
		else if(cmd.substring(0,6)=="stock="){
			cmd = rmComma(cmd,6)
			pts = cmd.substring(6).split(',')			
			defineStock(pts)	
		}
		else if(cmd.substring(0,5)=="tool="){
			tool=parseFloat(cmd.substring(5))
			cmd = 'tool diameter = ' + tool +"\""
		}
		else if((cmd=="units") && (cmd.length==5)){
			cmd=units
		}
		else if(cmd.substring(0,6)=="units="){
			cmd=cmd.substring(6,cmd.length)
			if((cmd =='cm') || (cmd =='CM')){
				units = 'cm'
				cmd='units=cm'
			}
			else if((cmd =='inch')||(cmd=="\"")){
				units = 'inch'
				cmd='units=inch'
			}
		}
		else if((cmd=="?") || (cmd=="help")){
			d = new Date()
			console.log(help)
			cmd = "console.log(help)"
			if(fabmo.isPresent()==true){
				fabmo.notify('info',help + '<font style=\'display:none\'>' + d.toLocaleString() + '</font>')
			}
			else{
				help = help.replace(/<br>/g,'')
				alert(help)
			}
		}
		else if(cmd=="settings"){

			var settings="\
			stock = " + (stock[0]/grid) + "," + (stock[1]/grid) +" <br>\n\
			tool diameter = " + tool + " <br>\n\
			units = " + units +" <br>\n\
			"
			settings = settings.replace(/\t/g,'')
			console.log(settings)

			d = new Date()

			if(fabmo.isPresent()==true){
				fabmo.notify('info',settings + '<font style=\'display:none\'>' + d.toLocaleString() + '</font>')
			}
			else{
				settings = settings.replace(/<br>/g,'')
				alert(settings)
			}

			cmd='console.log(settings)'
			
		}
		else if(cmd=="clear"){
			clearAll()
		}
		else if(cmd=="makedxf"){
			output='dxf'
			make()
		}
		else if(cmd=="makeg"){
			output='gcode'
			make()
		}
		else if(cmd=="makesbp"){
			output='sbp'
			make()
		}
		else if(cmd == "undo"){
			undo()
		}
		else if(cmd == "z"){
			zoom=4
			panX=0
			panY=0
			
		}
		else{
			cmd = "FabMo CAD \(enter \'?\' for help\)"
		}

		//console.log(cmd)
		document.getElementById('text-area').value = cmd + '\n\>\>'

		//$("#text-area").blur()
		
		makePath()
		draw()		
	}
})


function undo(){
	cutout=[]
	pockets=[]
	if(dogbones.length>0){
		dogbones=[]
		bones = []
	}
	else if(lines.length>2){
		lines.pop()
		point = [lines[lines.length-1][2],lines[lines.length-1][3]]
	}
	else{
		point=[0,0]
	}
	makePath()
}

function clearAll(){
	bones=[]
	stock=[3,3]
	lines=[]
	pockets=[]
	polygons=[]
	dogbones=[]
	cutout=[]
	point=[0,0]
	zoom=2
	panX=0
	panY=0
	draw()
	defineStock(stock)
	$('#clear').blur()
}

function scalePts(pts){
	for(i=0;i<pts.length;i++){
		pts[i]=pts[i]*grid
	}
}

function rect(pts){
	if(pts.length==4){
		lines.push([])
		lines[lines.length-1].push(pts[0],pts[1],(pts[0]+pts[2]),pts[1],(pts[0]+pts[2]),(pts[1]+pts[3]),(pts[0]),(pts[1]+pts[3]),pts[0],pts[1])
		point = [lines[lines.length-1][0],lines[lines.length-1][1]]
	}
	else if(pts.length==3){
		lines.push([])
		lines[lines.length-1].push(pts[0],pts[1],(pts[0]+pts[2]),pts[1],(pts[0]+pts[2]),(pts[1]+pts[2]),(pts[0]),(pts[1]+pts[2]),pts[0],pts[1])
		point = [lines[lines.length-1][0],lines[lines.length-1][1]]
	}
	
}

function line(pts){

	if(pts.length==4){
		lines.push(pts)
		point = [lines[lines.length-1][2],lines[lines.length-1][3]]
	}
	else if(pts.length==2){
		pts.splice(0,0,point[1])
		pts.splice(0,0,point[0])
		lines.push(pts)
		point = [lines[lines.length-1][2],lines[lines.length-1][3]]
	}	
}

function makeDogbones(pts){

	console.log(dogbones)

	for(i=0;i<pts.length;i++){
	
	Cx=parseFloat(pts[i].X)
	Cy=parseFloat(pts[i].Y)
	r=parseFloat(tool/2*grid)

	v=Math.ceil(r*2*Math.PI*30)
	//console.log(v)

	dogbones.push([])
		for(j=0;j<=v;j++){
			dogbones[dogbones.length-1].push((Cx)+Math.sin((Math.PI*2)/v*j)*r)
			dogbones[dogbones.length-1].push((Cy)+Math.cos((Math.PI*2)/v*j)*r)
			//dogbones[dogbones.length-1].push({X:(Cy)+Math.sin((Math.PI*2)/v*j)*r,Y:(Cx)+Math.cos((Math.PI*2)/v*j)*r})
		}

	}

	//console.log(dogbones)
	makePath()
	draw()

}


function circle(pts){
	
	Cx=parseFloat(pts[0])
	Cy=parseFloat(pts[1])
	r=parseFloat(pts[2])
	v=Math.ceil(r*2*Math.PI*30)
	//console.log(v)

	lines.push([])
		for(i=0;i<=v;i++){
			lines[lines.length-1].push((Cx)+Math.sin((Math.PI*2)/v*i)*r)
			lines[lines.length-1].push((Cy)+Math.cos((Math.PI*2)/v*i)*r)
		}
	
	//console.log(lines)
	point=[Cx,Cy]
	//point = [lines[lines.length-1][lines[lines.length-1].length-2],lines[lines.length-1][lines[lines.length-1].length-1]]
}

function star(pts){
	lines.push([])

	Cx=parseFloat(pts[0])
	Cy=parseFloat(pts[1])
	r=parseFloat(pts[2])
	v=5

	for(i=0;i<2;i++){
		j=0
		while(j<=4){
			lines[lines.length-1].push((Cx)+Math.sin((Math.PI*2)/v*(i+j))*r)
			lines[lines.length-1].push((Cy)+Math.cos((Math.PI*2)/v*(i+j))*r)
			j+=2
		}
	}

	point=[Cx,Cy]
	console.log(lines)

}

function zoomExtents(s){

	console.log(s[1]*gridSpace*sf)
	console.log(ctx.canvas.height)

}


function defineStock(pts){
	stock=[]
	
	panX=0-((pts[0]/2)*grid*gridSpace*sf)
	panY=(pts[1]/2)*grid*gridSpace*sf
	stock.push(parseFloat(pts[0]*grid),parseFloat(pts[1]*grid))

	draw()
}

function makePath(){

	paths=[]
	polygons = []

	for(i=0;i<lines.length;i++){
		paths.push([])
		for(j=0;j<lines[i].length;j+=2){
			paths[paths.length-1].push({X:lines[i][j]*scale,Y:lines[i][j+1]*scale})
		}			
	}

	if(inside==true){
	
		for(i=0;i<dogbones.length;i++){
			paths.push([])
			for(j=0;j<dogbones[i].length;j+=2){
				paths[paths.length-1].push({X:dogbones[i][j]*scale,Y:dogbones[i][j+1]*scale})
			}			
		}
	
	}
	else if(inside==false){
	
		var subtract = []
	
		for(i=0;i<dogbones.length;i++){
			subtract.push([])
			for(j=0;j<dogbones[i].length;j+=2){
				subtract[subtract.length-1].push({X:dogbones[i][j]*scale,Y:dogbones[i][j+1]*scale})
			}			
		}
	console.log(subtract)
	}

	while(paths.length>0){

	polygons.push(paths[0])
	paths.splice(0,1)

	for(i=0;i<paths.length;i++){
		end = polygons[polygons.length-1][polygons[polygons.length-1].length-1]
		start = polygons[polygons.length-1][0]

		if((paths[i][0].X==end.X)&&(paths[i][0].Y==end.Y)){
			for(j=0;j<paths[i].length;j++){
				polygons[polygons.length-1].push(paths[i][j])
			}
			paths.splice(i,1)
			i--
		}
		else if((paths[i][paths[i].length-1].X==end.X)&&(paths[i][paths[i].length-1].Y==end.Y)){
			for(j=paths[i].length-1;j>=0;j--){
				polygons[polygons.length-1].push(paths[i][j])
			}
			paths.splice(i,1)
			i--
		}
		else if((paths[i][0].X==start.X)&&(paths[i][0].Y==start.Y)){
			for(j=0;j<paths[i].length;j++){
				polygons[polygons.length-1].splice(0,0,paths[i][j])
			}
			paths.splice(i,1)
			i--
		}
		else if((paths[i][paths[i].length-1].X==start.X)&&(paths[i][paths[i].length-1].Y==start.Y)){
			for(j=paths[i].length-1;j>=0;j--){
				polygons[polygons.length-1].splice(0,0,paths[i][j])
			}
			paths.splice(i,1)
			i--
		}		
	}

	}

	//console.log(polygons)

	for(i=0;i<polygons.length;i++){
		var orientation = ClipperLib.Clipper.Orientation(polygons[i])
		if(orientation==false){
			polygons[i].reverse()
		}
	}

	paths = ClipperLib.Clipper.SimplifyPolygons(polygons, ClipperLib.PolyFillType.pftNonZero)
	polygons=paths

	var cpr = new ClipperLib.Clipper()
	cpr.AddPaths(polygons, ClipperLib.PolyType.ptSubject, true)

	var solution_paths = new ClipperLib.Paths()
	cpr.Execute(ClipperLib.ClipType.ctUnion, solution_paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
	polygons=solution_paths

	if(inside==false){

		cpr = new ClipperLib.Clipper()
		cpr.AddPaths(polygons, ClipperLib.PolyType.ptSubject, true)
		cpr.AddPaths(subtract, ClipperLib.PolyType.ptClip, true)
		cpr.Execute(ClipperLib.ClipType.ctDifference, solution_paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
		polygons=solution_paths

	}

	

	polygons = ClipperLib.JS.Clean(polygons, 0.015*scale)

	for(i=0;i<polygons.length;i++){
		for(j=0;j<polygons[i].length;j++){
			polygons[i][j].X=polygons[i][j].X/scale
			polygons[i][j].Y=polygons[i][j].Y/scale
		}
		polygons[i].push(polygons[i][0])
	}
	//console.log(polygons)
	
	//find90()
	draw()
}

function find90(){

	bones=[]

	//dbo = (Math.sqrt(Math.pow((tool/2),2)/2)*grid)
	dbo = (tool/2)*grid

	for(i=0;i<polygons.length;i++){
		
		for(j=0;j<polygons[i].length;j++){

			if((j!=0)&&(j!=polygons[i].length-1)){
				angle = ((Math.atan2(polygons[i][j+1].X-polygons[i][j].X, polygons[i][j+1].Y-polygons[i][j].Y) - Math.atan2(polygons[i][j].X-polygons[i][j-1].X,polygons[i][j].Y-polygons[i][j-1].Y) + Math.PI * 2) % (Math.PI * 2)) - Math.PI;
				var a = Math.atan2(polygons[i][j+1].X-polygons[i][j].X, polygons[i][j+1].Y-polygons[i][j].Y)
			}
			else if(j==0){
				//console.log(polygons)
				var angle = ((Math.atan2(polygons[i][j+1].X-polygons[i][j].X, polygons[i][j+1].Y-polygons[i][j].Y) - Math.atan2(polygons[i][j].X-polygons[i][polygons[i].length-2].X,polygons[i][j].Y-polygons[i][polygons[i].length-2].Y) + Math.PI * 2) % (Math.PI * 2)) - Math.PI;
				var a = Math.atan2(polygons[i][j+1].X-polygons[i][j].X, polygons[i][j+1].Y-polygons[i][j].Y)
			}

			angle = Math.round(angle*(180/Math.PI))
			if(Math.abs(angle)==90){
				bones.push(polygons[i][j])
				bones[bones.length-1].A = a+0.7853
			}

		}
		
	}

	

	db = []	
	for(i=0;i<bones.length;i++){
		db.push([])

		for(j=0;j<4;j++){

			db[db.length-1].push({X:(bones[i].X)+Math.sin((Math.PI*2)/4*j+bones[i].A)*dbo,Y:(bones[i].Y)+Math.cos((Math.PI*2)/4*j+bones[i].A)*dbo})

		}

	}

	bones=db

	dogbonePts(inside)

}

function dogbonePts(dbin){

	db=[]

	inside = dbin
   // 0 = false
   //-1 = on
   // 1 = in

	for(i=0;i<polygons.length;i++){

		for(j=0;j<bones.length;j++){
			db.push([])
			for(k=0;k<bones[j].length;k++){
				inpg = ClipperLib.Clipper.PointInPolygon(bones[j][k], polygons[i])
				if(inside==true){
					if(inpg==1){
						db[db.length-1].push(bones[j][k])
					}
				}
				else if(inside==false){
					if(inpg==0){
						db[db.length-1].push(bones[j][k])
					}
				}
			}

			if((db[db.length-1].length>1)&&(inside==true)){
				db.pop()
			}


			if(inside==false){

				if(db[db.length-1].length>1){
					db.pop()
				}

			}

		}		
	
	}

	bones=[]
	for(i=0;i<db.length;i++){
		if(db[i].length>0){
		bones.push(db[i][0])
		}
	}
	
	if(bones.length>0){
		makeDogbones(bones)
	}	
}


function pocket(){

cutout=[]

pockets=polygons

for(i=0;i<pockets.length;i++){
	pockets[i].pop()
	for(j=0;j<pockets[i].length;j++){		
	}
}
ClipperLib.JS.ScaleUpPaths(pockets, scale)
var co = new ClipperLib.ClipperOffset(0.25, 0.25)
co.AddPaths(pockets, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon)

pockets=[]
o=1
while(o>0){
	offset = new ClipperLib.Paths()

	co.Execute(offset,-(tool/2*grid*o) * scale)

	if(offset.length!=0){
		o++
		for(i=0;i<offset.length;i++){
			pockets.push(offset[i])
		}
	}
	else{
		o=0
	}
}

pockets.reverse()

ClipperLib.JS.ScaleDownPaths(pockets, scale)

//sort

draw()

}


function cutOut(out){

pockets=[]

cutout=polygons

for(i=0;i<cutout.length;i++){
	cutout[i].pop()
	for(j=0;j<cutout[i].length;j++){		
	}
}

ClipperLib.JS.ScaleUpPaths(cutout, scale)
var co = new ClipperLib.ClipperOffset(0.25, 0.25)
co.AddPaths(cutout, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon)
cutout = new ClipperLib.Paths()
if(out==true){
	co.Execute(cutout,(tool/2*grid) * scale)
}
else if(out==false){
	co.Execute(cutout,-(tool/2*grid) * scale)
}

ClipperLib.JS.ScaleDownPaths(cutout, scale)

draw()

}

$("body").keydown(function(e){

	if(e.keyCode == 37){
		//console.log("left")
		//panX-=gridSpace/2*sf
	}
	else if(e.keyCode == 38){
		//console.log("up")
		//panY-=gridSpace/2*sf
	}
	else if(e.keyCode == 39){
		//console.log("right")
		//panX+=gridSpace/2*sf
	}
	else if(e.keyCode == 40){
		//console.log("down")
		//panY+=gridSpace/2*sf
	}
	else if(e.keyCode == 90){
		//console.log("zoom extents")
		panX=0
		panY=0
	}
	
	draw()
})

$("#cad-canvas").on('click',function(e){

	ts=(e.timeStamp-ts)

	if(ts<=180){

	x = Math.round(((e.originalEvent.clientX-ctx.canvas.width/2)/gridSpace/sf)-panX/gridSpace/sf)
	y = Math.round(0-(Math.round(((e.originalEvent.clientY-ctx.canvas.height/2)/gridSpace/sf)-panY/gridSpace/sf)))

	//single line	
	if(lines.length==0){
		point=[x,y]
		lines.push([x,y])
	}
	else if(lines[lines.length-1].length>=4){
		point=[x,y]
		lines.push([x,y])
	}
	else if(lines[lines.length-1].length==2){
		lines[lines.length-1].push(x)
		lines[lines.length-1].push(y)
		point=[x,y]
	}
	//
	makePath()
	draw()
	}

})



$("#cad-canvas").on('touchstart mousedown', function(e) {

	ts=e.timeStamp
	pan=true

	if(e.type=='touchstart'){
		console.log('touchstart')
		if(e.originalEvent.touches.length==2){
			pan=false
			//console.log(zoom)
			zoomStart = Math.sqrt((e.originalEvent.touches[0].clientX-e.originalEvent.touches[1].clientX) * (e.originalEvent.touches[0].clientX-e.originalEvent.touches[1].clientX) + (e.originalEvent.touches[0].clientY-e.originalEvent.touches[1].clientY) * (e.originalEvent.touches[0].clientY-e.originalEvent.touches[1].clientY))
		}
		else{
			panStart.x=e.originalEvent.touches[0].clientX
			panStart.y=e.originalEvent.touches[0].clientY
		}
	}
	else{
		
		panStart.x=e.clientX
		panStart.y=e.clientY
	}

})


$("#cad-canvas").on('touchend mouseup', function(e) {

	pan=false	
	panX+=mousePanX
	panY+=mousePanY
	mousePanX=0
	mousePanY=0
	
	draw()

})

$("#cad-canvas").on('touchmove mousemove', function(e) {

	e.preventDefault()

	if(pan==false){
		mouseX = (Math.round(((e.originalEvent.clientX-ctx.canvas.width/2)/gridSpace/sf)-panX/gridSpace/sf)*sf*gridSpace)
		mouseY = (Math.round(((e.originalEvent.clientY-ctx.canvas.height/2)/gridSpace/sf)-panY/gridSpace/sf)*sf*gridSpace)
	}

	if((e.timeStamp-ts)>180){

		if(pan==true){

		if(e.type=='touchmove'){
			panEnd.x=e.originalEvent.touches[0].clientX
			panEnd.y=e.originalEvent.touches[0].clientY
		}
		else{
			panEnd.x=e.clientX
			panEnd.y=e.clientY
		}

			mousePanX=0-(panStart.x-panEnd.x)
			mousePanY=0-(panStart.y-panEnd.y)
			
		}

	}
	else if(e.type=='touchmove'){
		//zoom
		if(pan==false){
			if(e.originalEvent.touches.length==2){
				//console.log(zoom)
				dist = Math.sqrt((e.originalEvent.touches[0].clientX-e.originalEvent.touches[1].clientX) * (e.originalEvent.touches[0].clientX-e.originalEvent.touches[1].clientX) + (e.originalEvent.touches[0].clientY-e.originalEvent.touches[1].clientY) * (e.originalEvent.touches[0].clientY-e.originalEvent.touches[1].clientY))
				if((parseFloat(zoomStart/dist))<1){
					zoom+=0.05
				}
				else{
					zoom+=-0.05
				}
			
				//min/max
				if(zoom<0.8){
					zoom = 0.8
				}
				else if(zoom>10){
					zoom = 10
				}
			}
		}
	}
	draw()

})

$("#cad-canvas").on('mousewheel',function(e){
	e.preventDefault()

	zoom = parseFloat((zoom+(e.deltaY)/10).toFixed(3))

	if(zoom<0.8){
		zoom = 0.8
	}
	else if(zoom>10){
		zoom = 10
	}
	//console.log(zoom)
	draw()
})




</script>


</html>

